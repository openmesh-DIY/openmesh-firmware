/*
 * OpenMesh v0.1.3ps (pre-stable)
 * --------------------------------
 * Works on real hardware.
 * Survives RF noise.
 * Does NOT tolerate stupidity.
 *
 * Known facts:
 *  - Clean breadboards are fine
 *  - Old / oxidized / cursed breadboards are RF sabotage
 *  - Long wires = antennas you didn’t ask for
 *
 * If this breaks:
 *  1) Check wiring
 *  2) Check power
 *  3) Check GND
 *  4) Then read the code again, slowly
 *  5) or don't use crusty breadboards
 * If you "refactor" crypto or LoRa without understanding it,
 * you didn't improve it — you removed correctness.
 */

#include <SPI.h>
#include <LoRa.h>
#include <Wire.h>
#include <U8g2lib.h>
#include <OneButton.h>
#include "mbedtls/gcm.h"
#include <Preferences.h>
#include "BluetoothSerial.h"

// ================= FIXED CONFIG =================
// These values are not decorative.
// They exist because RF, timing, and entropy are real things.
//
// Changing random numbers until "it works"
// is not engineering — it's gambling.

#define BROADCAST_ID 0xFFFF
#define MAX_TTL 8
#define LORA_SYNCWORD 0x12
#define IV_SIZE 12
#define TAG_SIZE 16
#define MSG_COUNT 4

enum Preset { LONG_SLOW, LONG_FAST, MED_FAST, SHORT_FAST };
// FIXED: Changed 'char text;' to 'char text[20];' to allow string copying
struct MeshMsg { char text[20]; uint32_t timestamp; bool isTX; bool active = false; };
struct __attribute__((packed)) OpenMeshHeader { uint8_t version; uint8_t ttl; uint16_t src; uint16_t dest; uint16_t msg_id; uint16_t payload_len; };

// AES-256-GCM Key (FIXED: Added array brackets [])
// AES-256-GCM mesh key
// Same key on all nodes = same mesh
// Different key = invisible nodes
// This is not optional and not negotiable
// Why AES-GCM?
//  - Encryption + authentication in one shot
//  - No DIY MAC spaghetti
//  - No silent corruption
//
// Nonce / IV handling:
//  - GCM doesn’t magically forgive reuse (don’t be stupid)
//  - But it FAILS HONESTLY on desync
//  - Wrong nonce = packet dropped, not hallucinated
//
// Translation:
//  - I don’t have to hand-roll IV logic at 3 AM
//  - I don’t have to debug “why does this decrypt but lie”
//  - RF already hates me, crypto doesn’t need to join

unsigned char mesh_key[] = {0x1A,0x2B,0x3C,0x4D,0x5E,0x6F,0x70,0x81,0x92,0xA3,0xB4,0xC5,0xD6,0xE7,0xF8,0x09,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xAA,0xBB,0xCC,0xDD,0xEE,0xFF,0x00};

// ================= HARDWARE PINS =================
// Clean breadboards: OK
// Cheap, old, loose breadboards: absolutely not OK
//
// Symptoms of bad breadboards:
//  - Random packets
//  - No RX
//  - RX works only when you touch the wires
//
// That is not software.
// That is physics laughing at you.

#define BUTTON_PIN 13
#define OLED_SDA 21
#define OLED_SCL 22
#define LORA_SCK 18
#define LORA_MISO 19
#define LORA_MOSI 23
#define LORA_SS 5
#define LORA_RST 14
#define LORA_DIO0 26

U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE, OLED_SCL, OLED_SDA);
OneButton button(BUTTON_PIN, true);
BluetoothSerial SerialBT;

// System State
uint16_t nodeID; String nodeName;
int menuIdx = 0; Preset currentP = LONG_SLOW;
long freq = 433000000L;
int lastRSSI = -128, noiseFloor = -128;
float lastSNR = 0;
uint32_t relayedCount = 0, txPkts = 0, rxPkts = 0;
MeshMsg terminal[MSG_COUNT];
// FIXED: Changed 'uint16_t neighbors;' to 'uint16_t neighbors[5];'
uint16_t neighbors[5]; int neighborCount = 0;
// FIXED: Changed 'uint32_t seenMsgs;' to 'uint32_t seenMsgs[12];'
uint32_t seenMsgs[12]; int seenIdx = 0;

// ================= LOGO BITMAP DATA =================

// All 0x00 = you drew nothing.
// OLED is honest. It shows exactly what you gave it.

// FIXED: Added array brackets [] to the declaration
const unsigned char PROGMEM openmesh_logo_bits[1024] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF4,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE7,0x71,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x33,0xE6,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x38,0x86,0x03,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x18,0x0C,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x0C,0x1C,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x84,0x07,0x0C,0x18,0xF0,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x9F,0x01,0x06,0x30,0xC0,0x7C,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x80,0x31,0x00,0x07,0x20,0x00,0xE6,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x80,0x31,0x00,0x1B,0x60,0x00,0xC6,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x80,0x31,0x00,0x18,0x00,0x00,0xC6,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x80,0x3B,0x00,0x18,0x00,0x00,0xEE,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x18,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x18,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x1C,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x06,0x00,0xFE,0x3F,0x00,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x06,0x30,0x00,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x06,0x30,0x00,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x46,0x34,0x00,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x0E,0x04,0xE6,0x34,0x10,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x0E,0x06,0xB6,0x32,0x30,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x0E,0x07,0x96,0x33,0x70,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x0E,0x03,0x16,0x31,0x60,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x8E,0x01,0x06,0x30,0xC0,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x8E,0x01,0x06,0x30,0xC0,0x11,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0xCE,0x00,0x06,0x30,0x80,0x11,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x6E,0x00,0x06,0x30,0x00,0x13,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x64,0x00,0xFE,0x3F,0x00,0x13,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x0E,0x00,0x00,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x80,0x31,0x00,0x80,0x00,0x00,0xC6,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x80,0xB1,0xFF,0xDF,0xFC,0xFF,0xC6,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x80,0x31,0xFF,0xDF,0xFC,0x7F,0xC6,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x80,0x3B,0x00,0xC0,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x9F,0x01,0xC0,0x00,0xC0,0x7D,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x84,0x07,0xC0,0x00,0xF0,0x10,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0xC0,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x38,0xC0,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xC0,0x80,0x07,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x03,0xE0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC7,0x71,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE4,0x13,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


// ================= CORE FUNCTIONS =================

void addTerminal(const char* msg, bool tx) {
    for (int i = 0; i < MSG_COUNT - 1; i++) terminal[i] = terminal[i+1];
    strncpy(terminal[MSG_COUNT-1].text, msg, 19);
    terminal[MSG_COUNT-1].timestamp = millis();
    terminal[MSG_COUNT-1].isTX = tx;
    terminal[MSG_COUNT-1].active = true;
}

// Full LoRa re-init on purpose.
// RF state machines are fragile.
// Partial reconfig = undefined behavior.
//
// If you think this is "inefficient",
// you have never debugged RF at 2am.

void applyLoRa() {
    LoRa.end();
    SPI.begin(LORA_SCK, LORA_MISO, LORA_MOSI, LORA_SS);
    LoRa.setPins(LORA_SS, LORA_RST, LORA_DIO0);
    if (!LoRa.begin(freq)) return;
    
    if(currentP == LONG_SLOW)   { LoRa.setSpreadingFactor(12); LoRa.setSignalBandwidth(62500); }
    else if(currentP == LONG_FAST)  { LoRa.setSpreadingFactor(11); LoRa.setSignalBandwidth(250000); }
    else if(currentP == MED_FAST)   { LoRa.setSpreadingFactor(9);  LoRa.setSignalBandwidth(250000); }
    else if(currentP == SHORT_FAST) { LoRa.setSpreadingFactor(7);  LoRa.setSignalBandwidth(250000); }

    LoRa.setCodingRate4(5); LoRa.setSyncWord(LORA_SYNCWORD); LoRa.enableCrc(); LoRa.receive();
}

void secure_send(const char* msg, uint16_t dest) {

// Encrypts + sends a packet using AES-256-GCM


    int len = strlen(msg);
    uint8_t iv[IV_SIZE], tag[TAG_SIZE]; 
    // FIXED: Made ciphertext an array large enough for the message
    uint8_t ciphertext[100];

    for(int i=0; i<IV_SIZE; i++) iv[i] = esp_random() % 256;

    mbedtls_gcm_context gcm; mbedtls_gcm_init(&gcm);
    mbedtls_gcm_setkey(&gcm, MBEDTLS_CIPHER_ID_AES, mesh_key, 256);
    // FIXED: Passed array pointers instead of single char
    mbedtls_gcm_crypt_and_tag(&gcm, MBEDTLS_GCM_ENCRYPT, len, iv, IV_SIZE, NULL, 0, (const uint8_t*)msg, ciphertext, TAG_SIZE, tag);
    mbedtls_gcm_free(&gcm);

    OpenMeshHeader h = {2, MAX_TTL, nodeID, dest, (uint16_t)random(0, 65535), (uint16_t)len};
    LoRa.beginPacket();
    LoRa.write((uint8_t*)&h, sizeof(h)); LoRa.write(iv, IV_SIZE); LoRa.write(tag, TAG_SIZE); 
    // FIXED: Passed array pointer instead of single char
    LoRa.write(ciphertext, len);
    LoRa.endPacket(true); LoRa.receive();
    txPkts++; addTerminal(msg, true);
}

// ================= UI SYSTEM =================

// OLED is not decoration.
// It's a debugging instrument.
//
// If OLED looks sane but RF doesn’t:
//  - Your RF path is broken
//  - The code is fine

void drawUI() {
    u8g2.clearBuffer();
    u8g2.setDrawColor(1); u8g2.drawBox(0,0,128,12); u8g2.setDrawColor(0);
    u8g2.setFont(u8g2_font_6x10_tf); u8g2.setCursor(2, 9); u8g2.print(nodeName);
    u8g2.setCursor(95, 9); u8g2.print(freq/1000000.0, 1); u8g2.setDrawColor(1);

    if (menuIdx == 0) { // TERMINAL LOG
        for (int i = 0; i < MSG_COUNT; i++) {
            if (!terminal[i].active) continue;
            int y = 25 + (i * 10);
            int diff = (millis() - terminal[i].timestamp) / 60000;
            u8g2.setFont(u8g2_font_4x6_tf); u8g2.setCursor(0, y); u8g2.printf("[%dm]", diff);
            u8g2.setFont(u8g2_font_5x8_tf); u8g2.setCursor(25, y); 
            u8g2.print(terminal[i].isTX ? "TX:" : "RX:"); u8g2.setCursor(42, y); u8g2.print(terminal[i].text);
        }
        u8g2.drawLine(0, 56, 128, 56); u8g2.setFont(u8g2_font_4x6_tf);
        u8g2.setCursor(0, 63); u8g2.printf("RSSI:%d SNR:%.1f RLY:%u", lastRSSI, lastSNR, relayedCount);
    } 
    else if (menuIdx == 1) { // SIGNAL MONITOR
        u8g2.setCursor(2, 22); u8g2.print("SIGNAL MONITOR:");
        int bar = map(lastRSSI, -128, -30, 0, 100);
        u8g2.drawFrame(10, 35, 108, 10); u8g2.drawBox(10, 35, constrain(bar,0,108), 10);
        u8g2.setCursor(10, 55); u8g2.printf("LIVE RSSI: %d dBm", lastRSSI);
    }
    else if (menuIdx == 2) { // NEIGHBORS
        u8g2.setCursor(2, 22); u8g2.print("NEIGHBORS:");
        for(int i=0; i<neighborCount; i++) { u8g2.setCursor(10, 34+(i*9)); u8g2.printf("NODE: %04X", neighbors[i]); }
    }
    else if (menuIdx == 3) { // PRESET SELECTOR
        u8g2.setCursor(2, 22); u8g2.print("MODEM PRESET:");
        const char* names[] = {"LONG-SLOW", "LONG-FAST", "MED-FAST", "SHRT-FAST"};
        for(int i=0; i<4; i++) { u8g2.setCursor(10, 34+(i*8)); if(currentP == i) u8g2.print("[X] "); else u8g2.print("[ ] "); u8g2.print(names[i]); }
    }
    else if (menuIdx == 4) { // REAL-TIME NOISE FLOOR
        u8g2.setCursor(2, 22); u8g2.print("NOISE SCAN:");
        u8g2.setFont(u8g2_font_logisoso16_tf); u8g2.setCursor(20, 50); u8g2.print(noiseFloor); u8g2.print(" dBm");
    }
    else if (menuIdx == 5) { // TRAFFIC STATS
        u8g2.setCursor(2, 22); u8g2.print("STATS:");
        u8g2.setCursor(10, 35); u8g2.printf("TX PKTS: %u", txPkts);
        u8g2.setCursor(10, 45); u8g2.printf("RX PKTS: %u", rxPkts);
        u8g2.setCursor(10, 55); u8g2.printf("RELAYS : %u", relayedCount);
    }
    else if (menuIdx == 6) { // NODE HEALTH & HW TEST
        u8g2.setCursor(10, 25); u8g2.print("WIRING TEST: OK");
        u8g2.setCursor(10, 40); u8g2.printf("UPTIME: %lu min", millis()/60000);
        u8g2.setCursor(10, 55); u8g2.printf("HEX ID: 0x%04X", nodeID);
    }
    u8g2.sendBuffer();
}

// ================= BLUETOOTH COMMANDS =================

void handleBT() {
    if (!SerialBT.available()) return;
    String input = SerialBT.readStringUntil('\n'); input.trim();
    if (input.length() == 0) return;

    if (input.startsWith("/")) {
        if (input == "/status") SerialBT.printf("RSSI:%d SNR:%.1f Freq:%ld\n", lastRSSI, lastSNR, freq);
        else if (input.startsWith("/preset ")) {
            int p = input.substring(8).toInt();
            if (p >= 0 && p <= 3) { currentP = (Preset)p; applyLoRa(); SerialBT.printf("Preset -> %d\n", p); drawUI(); }
        }
        else if (input.startsWith("/freq ")) {
            freq = input.substring(6).toFloat() * 1000000L; applyLoRa(); SerialBT.printf("Freq set to %ld\n", freq); drawUI();
        }
        else if (input == "/id") SerialBT.printf("ID: %04X Name: %s\n", nodeID, nodeName.c_str());
        else if (input == "/reboot") ESP.restart();
        return; 
    }
    secure_send(input.c_str(), BROADCAST_ID); drawUI();
}

// ================= SETUP & LOOP =================

void setup() {
    u8g2.begin();
    Serial.begin(115200); 
    nodeID = (uint16_t)ESP.getEfuseMac();
    nodeName = "CORE-" + String(nodeID, HEX); nodeName.toUpperCase();
    SerialBT.begin(nodeName);

    // Initial Hardware Test with
 Auto-Exit
// Boot-time hardware test
// Fails fast, loudly, and honestly.
//
// If this hangs:
//  - Wiring is wrong
//  - Or power is trash
//  - Or both
//  - Or learn to use a proto PCB 

    uint32_t startTest = millis();
    while (millis() - startTest < 3000) { 
        u8g2.clearBuffer();
        
        // Drawing the 128x64 image
        u8g2.drawXBMP(0, 0, 128, 64, openmesh_logo_bits);
        
        u8g2.setFont(u8g2_font_4x6_tf);
        LoRa.setPins(5, 14, 26);
        if (!LoRa.begin(freq)) {
            u8g2.setCursor(0, 63); u8g2.print("LORA FAILED! CHECK WIRING"); 
            u8g2.sendBuffer(); 
            while(1); 
        }
        u8g2.setCursor(0, 63); u8g2.print("Hardware Test: OK"); 
        u8g2.sendBuffer(); 
        delay(100); 
    }
    
    u8g2.clearBuffer();

    button.attachClick([](){ 
        if(menuIdx == 3) { currentP = (Preset)((currentP + 1) % 4); applyLoRa(); } 
        else { menuIdx = (menuIdx + 1) % 7; } drawUI(); 
    });
    button.attachDoubleClick([](){ menuIdx = (menuIdx + 1) % 7; drawUI(); });
    button.attachLongPressStart([](){ freq += 1000000L; if(freq > 450000000L) freq = 410000000L; applyLoRa(); drawUI(); });

    applyLoRa(); addTerminal("MESH ONLINE", true);
}

// Main loop:
//  - Poll button
//  - Handle Bluetooth
//  - Listen to the air
//
// If nothing happens:
//  - Either nobody transmitted
//  - Or your antenna is a lie
//  - Or I forgot something to put here

void loop() {
    button.tick(); handleBT();

    noiseFloor = LoRa.packetRssi(); 
    if (menuIdx == 4) drawUI(); 

    int sz = LoRa.parsePacket();
    if (sz >= sizeof(OpenMeshHeader) + IV_SIZE + TAG_SIZE) {
        lastRSSI = LoRa.packetRssi(); lastSNR = LoRa.packetSnr(); rxPkts++;
        OpenMeshHeader h; LoRa.readBytes((uint8_t*)&h, sizeof(h));
        uint8_t iv[IV_SIZE], tag[TAG_SIZE];
        // FIXED: Made ciphertext and plaintext arrays
        uint8_t ciphertext[100], plaintext[100];
        LoRa.readBytes(iv, IV_SIZE); LoRa.readBytes(tag, TAG_SIZE);
        int pLen = h.payload_len; 
        // FIXED: Passed array pointer instead of single char
        LoRa.readBytes(ciphertext, pLen);

        mbedtls_gcm_context gcm; mbedtls_gcm_init(&gcm);
        mbedtls_gcm_setkey(&gcm, MBEDTLS_CIPHER_ID_AES, mesh_key, 256);
        // FIXED: Passed array pointers instead of single chars
        if (mbedtls_gcm_auth_decrypt(&gcm, pLen, iv, IV_SIZE, NULL, 0, tag, TAG_SIZE, ciphertext, plaintext) == 0) {
            plaintext[pLen] = '\0'; addTerminal((char*)plaintext, false);
            SerialBT.printf("IN [%04X]: %s\n", h.src, (char*)plaintext);
            bool known = false;
            for(int i=0; i<neighborCount; i++) if(neighbors[i] == h.src) known = true;
            if(!known && neighborCount < 5) neighbors[neighborCount++] = h.src;
        }
        mbedtls_gcm_free(&gcm); drawUI();
    }
    static uint32_t lastUI = 0;
    if (millis() - lastUI > 5000) { drawUI(); lastUI = millis(); }
}
